<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Apache Flink 1.2 Documentation: Flink DataStream API 编程指南</title>
    <link rel="shortcut icon" href="/1.2.0/page/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/1.2.0/page/favicon.ico" type="image/x-icon">

    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="/1.2.0/page/css/flink.css">
    <link rel="stylesheet" href="/1.2.0/page/css/syntax.css">
    <link rel="stylesheet" href="/1.2.0/page/css/codetabs.css">
    <link rel="stylesheet" href="/1.2.0/page/font-awesome/css/font-awesome.min.css">
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    
    
    

    <!-- Main content. -->
    <div class="container">
      
      <div class="row">
        <div class="col-lg-3">
          







  
    
    
    
      
    
  

  
    
    
    
      









  





<div class="sidenav-logo">
  <p><a href="/1.2.0"><img class="bottom" alt="Apache Flink" src="/1.2.0/page/img/navbar-brand-logo.jpg"></a> v1.2</p>
</div>
<ul id="sidenav">

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/index.html"><i class="fa fa-home title" aria-hidden="true"></i> 首页</a></li>
    
  

  
    

    
      
    

    
    
    

    <hr class="section-break"></hr>

    
    
      
      
        
        
<li><a href="#collapse-2" data-toggle="collapse"><i class="fa fa-map-o title appetizer" aria-hidden="true"></i> 概念 <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-2"><ul>
  
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
<li><a href="/1.2.0/concepts/programming-model.html">编程模型</a></li>
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/concepts/runtime.html">Distributed Runtime</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/quickstart/setup_quickstart.html"><i class="fa fa-power-off title appetizer" aria-hidden="true"></i> 快速起步</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-7" data-toggle="collapse"><i class="fa fa-file-code-o title appetizer" aria-hidden="true"></i> 示例 <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-7"><ul>
  <li><a href="/1.2.0/examples/index.html">Overview</a></li>
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/quickstart/run_example_quickstart.html">Monitoring Wikipedia Edits</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/batch/examples.html">Batch Examples</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    <hr class="section-break"></hr>

    
    
      
      
        
        
<li><a href="#collapse-11" data-toggle="collapse"><i class="fa fa-cogs title maindish" aria-hidden="true"></i> 建立工程 <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-11"><ul>
  
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/quickstart/java_api_quickstart.html">Java 的样例工程</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/quickstart/scala_api_quickstart.html">Scala 的样例工程</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/linking_with_flink.html">Linking with Flink</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/internals/ide_setup.html">IDE Setup</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/scala_shell.html">Scala REPL</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/linking.html">关联可选模块</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/setup/flink_on_windows.html">Running Flink on Windows</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/setup/building.html">Building Flink from Source</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-21" data-toggle="collapse" class="active"><i class="fa fa-code title maindish" aria-hidden="true"></i> 应用开发</a><div class="collapse in" id="collapse-21"><ul>
  
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-22" data-toggle="collapse">Basic API Concepts <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-22"><ul>
  <li><a href="/1.2.0/dev/api_concepts.html">Overview</a></li>
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/scala_api_extensions.html">Scala API Extensions</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/java8.html">Java 8</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-26" data-toggle="collapse" class="active">Streaming (DataStream API)</a><div class="collapse in" id="collapse-26"><ul>
  <li><a href="/1.2.0/dev/datastream_api.html" class="active">Overview</a></li>
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
<li><a href="/1.2.0/dev/windows.html">Windows</a></li>
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-28" data-toggle="collapse">Event Time <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-28"><ul>
  <li><a href="/1.2.0/dev/event_time.html">Overview</a></li>
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/event_timestamps_watermarks.html">Generating Timestamps / Watermarks</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/event_timestamp_extractors.html">预定义的 Timestamp Extractors / Watermark Emitters</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-32" data-toggle="collapse">Connectors <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-32"><ul>
  <li><a href="/1.2.0/dev/connectors/index.html">Overview</a></li>
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/connectors/guarantees.html">Fault Tolerance Guarantees</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/connectors/kafka.html">Kafka</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/connectors/cassandra.html">Cassandra</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/connectors/kinesis.html">Kinesis</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/connectors/elasticsearch.html">Elasticsearch</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/connectors/filesystem_sink.html">Rolling File Sink</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/connectors/rabbitmq.html">RabbitMQ</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/connectors/nifi.html">NiFi</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/connectors/twitter.html">Twitter</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/stream/process_function.html">过程函数</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/stream/side_output.html">Side Outputs</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/stream/state.html">Working with State</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/stream/checkpointing.html">Checkpointing</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/stream/asyncio.html">Async I/O</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/stream/queryable_state.html">Queryable State</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-50" data-toggle="collapse">批 (DataSet API) <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-50"><ul>
  <li><a href="/1.2.0/dev/batch/index.html">Overview</a></li>
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/batch/dataset_transformations.html">Transformations</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/batch/iterations.html">Iterations</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/batch/zip_elements_guide.html">Zipping Elements</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/batch/fault_tolerance.html">Fault Tolerance</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/batch/python.html">Python API</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/batch/connectors.html">Connectors</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/batch/hadoop_compatibility.html">Hadoop Compatibility</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/local_execution.html">Local Execution</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/cluster_execution.html">Cluster Execution</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-61" data-toggle="collapse">数据类型和序列化 <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-61"><ul>
  <li><a href="/1.2.0/dev/types_serialization.html">Overview</a></li>
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/custom_serializers.html">Custom Serializers</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-64" data-toggle="collapse">Managing Execution <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-64"><ul>
  
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/execution_configuration.html">Execution Configuration</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/packaging.html">Program Packaging</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/parallel.html">并行执行</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/execution_plans.html">执行计划</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/restart_strategies.html">Restart Strategies</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-71" data-toggle="collapse">Libraries <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-71"><ul>
  
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/table_api.html">Table and SQL</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/cep.html">Event Processing (CEP)</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/storm_compatibility.html">Storm Compatibility</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-75" data-toggle="collapse">Graphs: Gelly <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-75"><ul>
  <li><a href="/1.2.0/dev/libs/gelly/index.html">Overview</a></li>
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/gelly/graph_api.html">Graph API</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/gelly/iterative_graph_processing.html">Iterative Graph Processing</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/gelly/library_methods.html">Library Methods</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/gelly/graph_algorithms.html">Graph Algorithms</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/gelly/graph_generators.html">Graph Generators</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/gelly/bipartite_graph.html">Bipartite Graph</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-83" data-toggle="collapse">机器学习 <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-83"><ul>
  <li><a href="/1.2.0/dev/libs/ml/index.html">Overview</a></li>
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/ml/quickstart.html">快速入门</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/ml/multiple_linear_regression.html">多元线性回归</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/ml/cross_validation.html">交叉验证</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/ml/distance_metrics.html">距离度量</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/ml/knn.html">K近邻算法（KNN）</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/ml/min_max_scaler.html">最小最大值标准化</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/ml/contribution_guide.html">贡献指南</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/ml/pipelines.html">Pipelines</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/ml/polynomial_features.html">多项式特征转换</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/ml/als.html">ALS</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/ml/sos.html">Stochastic Outlier Selection</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/ml/standard_scaler.html">标准化缩放</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/libs/ml/svm.html">支持向量机（SVM using CoCoA）</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/best_practices.html">Best Practices</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/dev/migration.html">API Migration Guides</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-102" data-toggle="collapse"><i class="fa fa-sliders title maindish" aria-hidden="true"></i> 部署与运维 <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-102"><ul>
  
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
<li><a href="/1.2.0/setup/config.html">Configuration</a></li>
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/setup/cli.html">CLI</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-105" data-toggle="collapse">Clusters & Deployment <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-105"><ul>
  
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/setup/cluster_setup.html">Standalone Cluster</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/setup/yarn_setup.html">YARN</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/setup/mesos.html">Mesos</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/setup/aws.html">AWS</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/setup/gce_setup.html">Google Compute Engine</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/setup/mapr_setup.html">MapR</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/setup/jobmanager_high_availability.html">High Availability (HA)</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/setup/checkpoints.html">Checkpoints</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/setup/savepoints.html">Savepoints</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/setup/security-ssl.html">SSL Setup</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/ops/security-kerberos.html">Kerberos</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/ops/upgrading.html">Upgrading Applications and Flink Versions</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/ops/production_ready.html">生产环境检查清单</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    

    
    
      
      
        
        
<li><a href="#collapse-121" data-toggle="collapse"><i class="fa fa-bug title maindish" aria-hidden="true"></i> 调试与监控 <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-121"><ul>
  
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/monitoring/metrics.html">Metrics</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/monitoring/logging.html">Logging</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/monitoring/historyserver.html">History Server</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/monitoring/checkpoint_monitoring.html">Monitoring Checkpointing</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/monitoring/back_pressure.html">Monitoring Back Pressure</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/monitoring/rest_api.html">Monitoring REST API</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/monitoring/large_state_tuning.html">Debugging and Tuning Checkpoints and Large State</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/monitoring/debugging_event_time.html">Debugging Windows & Event Time</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/monitoring/debugging_classloading.html">Debugging Classloading</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/monitoring/application_profiling.html">Application Profiling</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    <hr class="section-break"></hr>

    
    
      
      
        
        
<li><a href="#collapse-133" data-toggle="collapse"><i class="fa fa-book title dessert" aria-hidden="true"></i> 内部原理 <i class="fa fa-caret-down pull-right" aria-hidden="true" style="padding-top: 4px"></i></a><div class="collapse" id="collapse-133"><ul>
  
        
        
        

        
        
      
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/internals/components.html">Component Stack</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/internals/stream_checkpointing.html">Fault Tolerance for Data Streaming</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/internals/job_scheduling.html">Jobs and Scheduling</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/internals/task_lifecycle.html">Task Lifecycle</a></li>
    
  

  
    

    
      
    

    
    
    

    

    
    
<li><a href="/1.2.0/internals/filesystems.html">File Systems</a></li>
    
  

  
    
      
      
</li></ul></div>
      
      
    
  

  
    

    
      
    

    
    
    

    <hr class="section-break"></hr>

    
    
<li><a href="/1.2.0/about/index.html"><i class="fa fa-fire title hot" aria-hidden="true"></i> 参与贡献</a></li>
    
  

  
    
      
  <li class="divider"></li>
  <li><a href="http://flink-china.org"><i class="fa fa-external-link title" aria-hidden="true"></i> 项目页面</a></li>
</ul>

<div class="sidenav-search-box">
  <form class="navbar-form" role="search" action="/1.2.0/search-results.html">
    <div class="form-group">
      <input type="text" class="form-control" size="16px" name="q" placeholder="搜索文档">
    </div>
    <button type="submit" class="btn btn-default">搜索</button>
  </form>
</div>

<div class="sidenav-versions">
  <div class="dropdown">
    <button class="btn btn-default dropdown-toggle" type="button" data-toggle="dropdown">选择文档版本
    <span class="caret"></span></button>
    <ul class="dropdown-menu">
      
      <li><a href="http://doc.flink-china.org/1.1.0/">v1.1</a></li>
      
    </ul>
  </div>
</div>

        </div>
        <div class="col-lg-9 content">
          

          





  
  
    
    
      
    
  

  
  
    
    
      



<ol class="breadcrumb">

  
  
    <li><i class="fa fa-code title maindish" aria-hidden="true"></i> 应用开发</li>
  

  
  
    <li class="active">Streaming (DataStream API)</li>
  

</ol>

<h1>Flink DataStream API 编程指南</h1>



<p>Flink中的DataStream程序是对数据流进行转换（例如，过滤、更新状态、定义窗口、聚合）的常用方式。数据流起于各种sources（例如，消息队列，socket流，文件）。通过sinks返回结果，例如将数据写入文件或标准输出（例如命令行终端）。Flink程序可以运行在各种上下文环境中，独立或嵌入其他程序中。
执行过程可能发生在本地JVM或在由许多机器组成的集群上。</p>

<p>关于Flink API的基本概念介绍请参阅<a href="/1.2.0/dev/api_concepts.html">基本概念</a>。</p>

<p>为了创建你的Flink DataStream程序，我们鼓励你从<a href="/1.2.0/dev/api_concepts.html#anatomy-of-a-flink-program">解构Flink程序</a>
开始，并逐渐添加你自己的<a href="#datastream-transformations">transformations</a>。本节其余部分作为附加操作和高级功能的参考。</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">示例程序</a></li>
  <li><a href="#datastream-transformations" id="markdown-toc-datastream-transformations">DataStream Transformations</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">物理分区</a></li>
      <li><a href="#chaining-" id="markdown-toc-chaining-">任务链接（chaining） 和资源组</a></li>
    </ul>
  </li>
  <li><a href="#sources" id="markdown-toc-sources">数据Sources</a></li>
  <li><a href="#sinks" id="markdown-toc-sinks">数据Sinks</a></li>
  <li><a href="#iterations" id="markdown-toc-iterations">迭代（Iterations）</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">执行参数</a>    <ul>
      <li><a href="#section-3" id="markdown-toc-section-3">容错</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">延迟控制</a></li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">调试</a>    <ul>
      <li><a href="#section-6" id="markdown-toc-section-6">本地执行环境</a></li>
      <li><a href="#sources-1" id="markdown-toc-sources-1">基于集合的数据Sources</a></li>
      <li><a href="#sink" id="markdown-toc-sink">迭代的数据Sink</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">示例程序</h2>

<p>以下是基于流式窗口进行word count的一个完整可运行的程序示例，它从网络socket中以5秒的窗口统计单词个数。你可以复制并粘贴代码用以本地运行。</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">org.apache.flink.api.common.functions.FlatMapFunction</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.api.java.tuple.Tuple2</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.streaming.api.datastream.DataStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.streaming.api.environment.StreamExecutionEnvironment</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.streaming.api.windowing.time.Time</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.util.Collector</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WindowWordCount</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

        <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

        <span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">dataStream</span> <span class="o">=</span> <span class="n">env</span>
                <span class="o">.</span><span class="na">socketTextStream</span><span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">9999</span><span class="o">)</span>
                <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="nf">Splitter</span><span class="o">())</span>
                <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
                <span class="o">.</span><span class="na">timeWindow</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">))</span>
                <span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="n">dataStream</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>

        <span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="s">&quot;Window WordCount&quot;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Splitter</span> <span class="kd">implements</span> <span class="n">FlatMapFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">String</span> <span class="n">sentence</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="nl">word:</span> <span class="n">sentence</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;(</span><span class="n">word</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></div>

  </div>

  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.streaming.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.streaming.api.windowing.time.Time</span>

<span class="k">object</span> <span class="nc">WindowWordCount</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>

    <span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>
    <span class="k">val</span> <span class="n">text</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">socketTextStream</span><span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">9999</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">counts</span> <span class="k">=</span> <span class="n">text</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">toLowerCase</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;\\W+&quot;</span><span class="o">)</span> <span class="n">filter</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">nonEmpty</span> <span class="o">}</span> <span class="o">}</span>
      <span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span>
      <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
      <span class="o">.</span><span class="n">timeWindow</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">))</span>
      <span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

    <span class="n">counts</span><span class="o">.</span><span class="n">print</span>

    <span class="n">env</span><span class="o">.</span><span class="n">execute</span><span class="o">(</span><span class="s">&quot;Window Stream WordCount&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </div>

</div>

<p>要运行示例程序，首先在终端启动netcat作为输入流：</p>

<div class="highlight"><pre><code class="language-bash">nc -lk 9999</code></pre></div>

<p>然后输入一些单词，回车换行输入新一行的单词。这些输入将作为示例程序的输入。如果要使得某个单词的计数大于1，请在5秒钟内重复输入相同的字词（如果5秒钟输入相同单词对你来说太快，请把示例程序中的窗口大小从5秒调大 ☺）。</p>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="datastream-transformations">DataStream Transformations</h2>

<p>数据的Transformations可以将一个或多个DataStream转换为一个新的DataStream。程序可以将多种Transformations组合成复杂的拓扑结构。</p>

<p>本节对所有可用Transformations进行详细说明。</p>

<div class="codetabs">
  <div data-lang="java">

    <p><br /></p>

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 25%">Transformation</th>
      <th class="text-center">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
          <td><strong>Map</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>读入一个元素，返回转换后的一个元素。一个把输入流转换中的数值翻倍的map function：</p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">dataStream</span> <span class="o">=</span> <span class="c1">//...</span>
<span class="n">dataStream</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">map</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></div>

          </td>
        </tr>

        <tr>
          <td><strong>FlatMap</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>读入一个元素，返回转换后的0个、1个或者多个元素。一个将句子切分成单词的flatmap function：</p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">FlatMapFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">String</span> <span class="n">value</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="nl">word:</span> <span class="n">value</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)){</span>
            <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Filter</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>对读入的每个元素执行boolean函数，并保留返回true的元素。一个过滤掉零值的filter：
            </p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>KeyBy</strong><br />DataStream &rarr; KeyedStream</td>
          <td>
            <p>逻辑上将流分区为不相交的分区，每个分区包含相同key的元素。在内部通过hash分区来实现。关于如何指定分区的keys请参阅<a href="/1.2.0/dev/api_concepts.html#specifying-keys">keys</a>。该transformation返回一个KeyedDataStream。</p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="s">&quot;someKey&quot;</span><span class="o">)</span> <span class="c1">// Key by field &quot;someKey&quot;</span>
<span class="n">dataStream</span><span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="c1">// Key by the first element of a Tuple</span></code></pre></div>

            <p>
            <span class="label label-danger">注意</span>
            以下类型<strong>不能作为key</strong>:
          <ol>
          <li> POJO类型，并且依赖于<em>Object.hashCode()</em>的实现，但是未覆写<em>hashCode()</em></li>
          <li> 任意类型的数组</li>
          </ol>
          </p>
          </td>
        </tr>
        <tr>
          <td><strong>Reduce</strong><br />KeyedStream &rarr; DataStream</td>
          <td>
            <p>在一个KeyedStream上不断进行reduce操作。将当前元素与上一个reduce后的值进行合并，再返回新合并的值。
                    <br />
              <br />
            一个构造局部求和流的reduce function：</p>
            
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">keyedStream</span><span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="k">new</span> <span class="n">ReduceFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value1</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">value2</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></div>

            
          </td>
        </tr>
        <tr>
          <td><strong>Fold</strong><br />KeyedStream &rarr; DataStream</td>
          <td>
          <p>在一个KeyedStream上基于初始值不断进行变换操作，将当前值与上一个变换后的值进行变换，再返回新变换的值。
          <br />
          <br />
          <p>&gt;在序列（1,2,3,4,5）上应用如下的fold function，返回的序列依次是“start-1”，“start-1-2”，“start-1-2-3”, ...：</p>
          
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
  <span class="n">keyedStream</span><span class="o">.</span><span class="na">fold</span><span class="o">(</span><span class="s">&quot;start&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">FoldFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">fold</span><span class="o">(</span><span class="n">String</span> <span class="n">current</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">current</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">});</span></code></pre></div>

          </p>
          </td>
        </tr>
        <tr>
          <td><strong>Aggregations</strong><br />KeyedStream &rarr; DataStream</td>
          <td>
            <p>在一个KeyedStream上不断聚合。min和minBy的区别是min返回最小值，而minBy返回在该字段上值为最小值的所有元素（对于max和maxBy相同）。</p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">keyedStream</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Window</strong><br />KeyedStream &rarr; WindowedStream</td>
          <td>
            <p>Windows可定义在已分区的KeyedStreams上。Windows会在每个key对应的数据上根据一些特征（例如，在最近5秒内到达的数据）进行分组。
            有关Windows的完整说明请参阅<a href="windows.html">windows</a>。
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)));</span> <span class="c1">// Last 5 seconds of data</span></code></pre></div>

        </p>
          </td>
        </tr>
        <tr>
          <td><strong>WindowAll</strong><br />DataStream &rarr; AllWindowedStream</td>
          <td>
              <p>Windows可定义在普通DataStream上。Windows根据一些特征（例如，在最近5秒内到达的数据）对所有流事件进行分组。有关Windows的完整说明请参阅<a href="windows.html">windows</a>。</p>
              <p><strong>警告：</strong>在多数情况下，这是<strong>非并行</strong>的的transformation。所有记录将被聚集到运行windowAll操作的一个任务中。</p>
  
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">windowAll</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)));</span> <span class="c1">// Last 5 seconds of data</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Window Apply</strong><br />WindowedStream &rarr; DataStream<br />AllWindowedStream &rarr; DataStream</td>
          <td>
            <p>把窗口作为整体，并在此整体上应用通用函数。以下是手动对窗口全体元素求和的函数。</p>
            <p><strong>注意：</strong>如果你正在使用windowAll transformation，则需要替换为AllWindowFunction。</p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">windowedStream</span><span class="o">.</span><span class="na">apply</span> <span class="o">(</span><span class="k">new</span> <span class="n">WindowFunction</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Tuple</span><span class="o">,</span> <span class="n">Window</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span> <span class="o">(</span><span class="n">Tuple</span> <span class="n">tuple</span><span class="o">,</span>
            <span class="n">Window</span> <span class="n">window</span><span class="o">,</span>
            <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">values</span><span class="o">,</span>
            <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">value</span> <span class="nl">t:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="na">f1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">out</span><span class="o">.</span><span class="na">collect</span> <span class="o">(</span><span class="k">new</span> <span class="nf">Integer</span><span class="o">(</span><span class="n">sum</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">});</span>

<span class="c1">// applying an AllWindowFunction on non-keyed window stream</span>
<span class="n">allWindowedStream</span><span class="o">.</span><span class="na">apply</span> <span class="o">(</span><span class="k">new</span> <span class="n">AllWindowFunction</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Window</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span> <span class="o">(</span><span class="n">Window</span> <span class="n">window</span><span class="o">,</span>
            <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">values</span><span class="o">,</span>
            <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">value</span> <span class="nl">t:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="na">f1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">out</span><span class="o">.</span><span class="na">collect</span> <span class="o">(</span><span class="k">new</span> <span class="nf">Integer</span><span class="o">(</span><span class="n">sum</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Window Reduce</strong><br />WindowedStream &rarr; DataStream</td>
          <td>
            <p>在窗口上应用一个通用的reduce函数并返回reduced后的值。</p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">windowedStream</span><span class="o">.</span><span class="na">reduce</span> <span class="o">(</span><span class="k">new</span> <span class="n">ReduceFunction</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">value1</span><span class="o">,</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">value2</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;(</span><span class="n">value1</span><span class="o">.</span><span class="na">f0</span><span class="o">,</span> <span class="n">value1</span><span class="o">.</span><span class="na">f1</span> <span class="o">+</span> <span class="n">value2</span><span class="o">.</span><span class="na">f1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Window Fold</strong><br />WindowedStream &rarr; DataStream</td>
          <td>
            <p>在窗口上应用一个通用的fold函数并返回fold后的值。在序列（1,2,3,4,5）上应用示例函数，将会得到字符串“start-1-2-3-4-5”中：</p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">windowedStream</span><span class="o">.</span><span class="na">fold</span><span class="o">(</span><span class="s">&quot;start&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">FoldFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">fold</span><span class="o">(</span><span class="n">String</span> <span class="n">current</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">current</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Aggregations on windows</strong><br />WindowedStream &rarr; DataStream</td>
          <td>
            <p>聚合窗口的内容。min和minBy的区别是min返回最小值，而minBy返回在该字段上值为最小值的所有元素（对于max和maxBy相同）。</p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">windowedStream</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Union</strong><br />DataStream* &rarr; DataStream</td>
          <td>
            <p>联合（Union）两个或多个数据流，创建一个包含来自所有流的所有元素的新的数据流。注意：如果DataStream和自身联合，那么在结果流中每个元素你会拿到两份。</p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">otherStream1</span><span class="o">,</span> <span class="n">otherStream2</span><span class="o">,</span> <span class="o">...);</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Window Join</strong><br />DataStream,DataStream &rarr; DataStream</td>
          <td>
            <p>在给定的key和公共窗口上连接（Join）两个DataStream。</p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">otherStream</span><span class="o">)</span>
    <span class="o">.</span><span class="na">where</span><span class="o">(&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;).</span><span class="na">equalTo</span><span class="o">(&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;)</span>
    <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span>
    <span class="o">.</span><span class="na">apply</span> <span class="o">(</span><span class="k">new</span> <span class="nf">JoinFunction</span> <span class="o">()</span> <span class="o">{...});</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Window CoGroup</strong><br />DataStream,DataStream &rarr; DataStream</td>
          <td>
            <p>在给定的key和公共窗口上CoGroup两个DataStream。</p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">coGroup</span><span class="o">(</span><span class="n">otherStream</span><span class="o">)</span>
    <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span>
    <span class="o">.</span><span class="na">apply</span> <span class="o">(</span><span class="k">new</span> <span class="nf">CoGroupFunction</span> <span class="o">()</span> <span class="o">{...});</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Connect</strong><br />DataStream,DataStream &rarr; ConnectedStreams</td>
          <td>
            <p>“串联”(Connect)两个DataStream并保留各自类型。串联允许两个流之间共享状态。</p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">someStream</span> <span class="o">=</span> <span class="c1">//...</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">otherStream</span> <span class="o">=</span> <span class="c1">//...</span>

<span class="n">ConnectedStreams</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">connectedStreams</span> <span class="o">=</span> <span class="n">someStream</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">otherStream</span><span class="o">);</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>CoMap, CoFlatMap</strong><br />ConnectedStreams &rarr; DataStream</td>
          <td>
            <p>在一个ConnectedStreams上做类似map和flatMap的操作。</p>
    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">connectedStreams</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">CoMapFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Boolean</span> <span class="nf">map1</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Boolean</span> <span class="nf">map2</span><span class="o">(</span><span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="n">connectedStreams</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">CoFlatMapFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>

   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap1</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
   <span class="o">}</span>

   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap2</span><span class="o">(</span><span class="n">String</span> <span class="n">value</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="nl">word:</span> <span class="n">value</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span> <span class="o">{</span>
         <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
       <span class="o">}</span>
   <span class="o">}</span>
<span class="o">});</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Split</strong><br />DataStream &rarr; SplitStream</td>
          <td>
            <p>
                根据一些标准将流分成两个或更多个流。
                
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">SplitStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">split</span> <span class="o">=</span> <span class="n">someDataStream</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="k">new</span> <span class="n">OutputSelector</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">select</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;even&quot;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;odd&quot;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">output</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></div>

            </p>
          </td>
        </tr>
        <tr>
          <td><strong>Select</strong><br />SplitStream &rarr; DataStream</td>
          <td>
            <p>
                在一个SplitStream上选择一个或多个流。
                
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">SplitStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">split</span><span class="o">;</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">even</span> <span class="o">=</span> <span class="n">split</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="s">&quot;even&quot;</span><span class="o">);</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">odd</span> <span class="o">=</span> <span class="n">split</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="s">&quot;odd&quot;</span><span class="o">);</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">all</span> <span class="o">=</span> <span class="n">split</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="s">&quot;even&quot;</span><span class="o">,</span><span class="s">&quot;odd&quot;</span><span class="o">);</span></code></pre></div>

            </p>
          </td>
        </tr>
        <tr>
          <td><strong>Iterate</strong><br />DataStream &rarr; IterativeStream &rarr; DataStream</td>
          <td>
            <p>
                通过将一个operator的输出重定向到某个先前的operator，在流中创建“反馈”循环。这对于需要不断更新模型的算法特别有用。
                以下代码以流开始，并持续应用迭代体。大于0的元素将回送到反馈通道，其余元素发往下游。相关完整描述请参阅<a href="#iterations">iterations</a>。
                
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">IterativeStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">iteration</span> <span class="o">=</span> <span class="n">initialStream</span><span class="o">.</span><span class="na">iterate</span><span class="o">();</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">iterationBody</span> <span class="o">=</span> <span class="n">iteration</span><span class="o">.</span><span class="na">map</span> <span class="o">(</span><span class="cm">/*do something*/</span><span class="o">);</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">feedback</span> <span class="o">=</span> <span class="n">iterationBody</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;(){</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="n">iteration</span><span class="o">.</span><span class="na">closeWith</span><span class="o">(</span><span class="n">feedback</span><span class="o">);</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">iterationBody</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;(){</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></div>

            </p>
          </td>
        </tr>
        <tr>
          <td><strong>Extract Timestamps</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>
                从记录中提取时间戳，以便在窗口中使用事件时间语义。请参阅<a href="/1.2.0/dev/event_time.html">Event Time</a>。
                
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">stream</span><span class="o">.</span><span class="na">assignTimestamps</span> <span class="o">(</span><span class="k">new</span> <span class="nf">TimeStampExtractor</span><span class="o">()</span> <span class="o">{...});</span></code></pre></div>

            </p>
          </td>
        </tr>
  </tbody>
</table>

  </div>

  <div data-lang="scala">

    <p><br /></p>

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 25%">Transformation</th>
      <th class="text-center">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
          <td><strong>Map</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>读入一个元素，返回转换后的一个元素。一个把输入流转换中的数值翻倍的map function：</p>
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">}</span></code></pre></div>

          </td>
        </tr>

        <tr>
          <td><strong>FlatMap</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>读入一个元素，返回转换后的0个、1个或者多个元素。一个将句子切分成单词的flatmap function：</p>
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">str</span> <span class="k">=&gt;</span> <span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span> <span class="o">}</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Filter</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>对读入的每个元素执行boolean函数，并保留返回true的元素。一个过滤掉零值的filter：
            </p>
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">filter</span> <span class="o">{</span> <span class="k">_</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">}</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>KeyBy</strong><br />DataStream &rarr; KeyedStream</td>
          <td>
            <p>逻辑上将流分区为不相交的分区，每个分区包含相同key的元素。在内部通过hash分区来实现。关于如何指定分区的keys请参阅<a href="/1.2.0/dev/api_concepts.html#specifying-keys">keys</a>。该transformation返回一个KeyedDataStream。</p>
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="s">&quot;someKey&quot;</span><span class="o">)</span> <span class="c1">// Key by field &quot;someKey&quot;</span>
<span class="n">dataStream</span><span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="c1">// Key by the first element of a Tuple</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Reduce</strong><br />KeyedStream &rarr; DataStream</td>
          <td>
            <p>在一个KeyedStream上不断进行reduce操作。将当前元素与上一个reduce后的值进行合并，再返回新合并的值。
                    <br />
              <br />
            一个构造局部求和流的reduce function：</p>
            
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">keyedStream</span><span class="o">.</span><span class="n">reduce</span> <span class="o">{</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span> <span class="o">}</span></code></pre></div>

            
          </td>
        </tr>
        <tr>
          <td><strong>Fold</strong><br />KeyedStream &rarr; DataStream</td>
          <td>
          <p>在一个KeyedStream上基于初始值不断进行变换操作，将当前值与上一个变换后的值进行变换，再返回新变换的值。
          <br />
          <br />
          <p>在序列（1,2,3,4,5）上应用如下的fold function，返回的序列依次是“start-1”，“start-1-2”，“start-1-2-3”, ...：</p>
          
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">keyedStream</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="s">&quot;start&quot;</span><span class="o">)((</span><span class="n">str</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="n">str</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">})</span></code></pre></div>

          </p>
          </td>
        </tr>
        <tr>
          <td><strong>Aggregations</strong><br />KeyedStream &rarr; DataStream</td>
          <td>
            <p>在一个KeyedStream上不断聚合。min和minBy的区别是min返回最小值，而minBy返回在该字段上值为最小值的所有元素（对于max和maxBy相同）。</p>
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">keyedStream</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">minBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">minBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Window</strong><br />KeyedStream &rarr; WindowedStream</td>
          <td>
            <p>Windows可定义在已分区的KeyedStreams上。Windows会在每个key对应的数据上根据一些特征（例如，在最近5秒内到达的数据）进行分组。有关Windows的完整说明请参阅<a href="windows.html">windows</a>。
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">window</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)))</span> <span class="c1">// Last 5 seconds of data</span></code></pre></div>

        </p>
          </td>
        </tr>
        <tr>
          <td><strong>WindowAll</strong><br />DataStream &rarr; AllWindowedStream</td>
          <td>
              <p>Windows可定义在普通DataStream上。Windows根据一些特征（例如，在最近5秒内到达的数据）对所有流事件进行分组。有关Windows的完整说明请参阅<a href="windows.html">windows</a></p>。
              <p><strong>警告：</strong>在多数情况下，这是<strong>非并行</strong>的transformation。所有记录将被聚集到运行windowAll操作的一个任务中。</p>
  
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">windowAll</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)))</span> <span class="c1">// Last 5 seconds of data</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Window Apply</strong><br />WindowedStream &rarr; DataStream<br />AllWindowedStream &rarr; DataStream</td>
          <td>
            <p>把窗口作为整体，并在此整体上应用通用函数。以下是手动对窗口全体元素求和的函数。</p>
            <p><strong>注意：</strong>如果你正在使用windowAll transformation，则需要替换为AllWindowFunction</p>
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">windowedStream</span><span class="o">.</span><span class="n">apply</span> <span class="o">{</span> <span class="nc">WindowFunction</span> <span class="o">}</span>

<span class="c1">// applying an AllWindowFunction on non-keyed window stream</span>
<span class="n">allWindowedStream</span><span class="o">.</span><span class="n">apply</span> <span class="o">{</span> <span class="nc">AllWindowFunction</span> <span class="o">}</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Window Reduce</strong><br />WindowedStream &rarr; DataStream</td>
          <td>
            <p>在窗口上应用一个通用的reduce函数并返回reduced后的值。</p>
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">windowedStream</span><span class="o">.</span><span class="n">reduce</span> <span class="o">{</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span> <span class="o">}</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Window Fold</strong><br />WindowedStream &rarr; DataStream</td>
          <td>
            <p>在窗口上应用一个通用的fold函数并返回fold后的值。在序列（1,2,3,4,5）上应用示例函数，将会得到字符串“start-1-2-3-4-5”中：</p>
          
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">windowedStream</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="s">&quot;start&quot;</span><span class="o">,</span> <span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="n">str</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">})</span></code></pre></div>

          </td>
  </tr>
        <tr>
          <td><strong>Aggregations on windows</strong><br />WindowedStream &rarr; DataStream</td>
          <td>
            <p>聚合窗口的内容。min和minBy的区别是min返回最小值，而minBy返回在该字段上值为最小值的所有元素（对于max和maxBy相同）。</p>
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">windowedStream</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">minBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">minBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Union</strong><br />DataStream* &rarr; DataStream</td>
          <td>
            <p>联合（Union）两个或多个数据流，创建一个包含来自所有流的所有元素的新的数据流。注意：如果DataStream和自身联合，那么在结果流中每个元素你会拿到两份。</p>
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">union</span><span class="o">(</span><span class="n">otherStream1</span><span class="o">,</span> <span class="n">otherStream2</span><span class="o">,</span> <span class="o">...)</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Window Join</strong><br />DataStream,DataStream &rarr; DataStream</td>
          <td>
            <p>在给定的key和公共窗口上连接（Join）两个DataStream。</p>
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">otherStream</span><span class="o">)</span>
    <span class="o">.</span><span class="n">where</span><span class="o">(&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;).</span><span class="n">equalTo</span><span class="o">(&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span>
    <span class="o">.</span><span class="n">apply</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Window CoGroup</strong><br />DataStream,DataStream &rarr; DataStream</td>
          <td>
            <p>在给定的key和公共窗口上CoGroup两个DataStream。</p>
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">coGroup</span><span class="o">(</span><span class="n">otherStream</span><span class="o">)</span>
    <span class="o">.</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span>
    <span class="o">.</span><span class="n">apply</span> <span class="o">{}</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Connect</strong><br />DataStream,DataStream &rarr; ConnectedStreams</td>
          <td>
            <p>“串联”(Connect)两个DataStream并保留各自类型。串联允许两个流之间共享状态。</p>
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">someStream</span> <span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="n">otherStream</span> <span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">connectedStreams</span> <span class="k">=</span> <span class="n">someStream</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="n">otherStream</span><span class="o">)</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>CoMap, CoFlatMap</strong><br />ConnectedStreams &rarr; DataStream</td>
          <td>
            <p>在一个ConnectedStreams上做类似map和flatMap的操作。</p>
    
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">connectedStreams</span><span class="o">.</span><span class="n">map</span><span class="o">(</span>
    <span class="o">(</span><span class="k">_</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">,</span>
    <span class="o">(</span><span class="k">_</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">)</span>
<span class="n">connectedStreams</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span>
    <span class="o">(</span><span class="k">_</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">,</span>
    <span class="o">(</span><span class="k">_</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">)</span></code></pre></div>

          </td>
        </tr>
        <tr>
          <td><strong>Split</strong><br />DataStream &rarr; SplitStream</td>
          <td>
            <p>
                根据一些标准将流分成两个或更多个流。
                
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">split</span> <span class="k">=</span> <span class="n">someDataStream</span><span class="o">.</span><span class="n">split</span><span class="o">(</span>
  <span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;even&quot;</span><span class="o">)</span>
      <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;odd&quot;</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">)</span></code></pre></div>

            </p>
          </td>
        </tr>
        <tr>
          <td><strong>Select</strong><br />SplitStream &rarr; DataStream</td>
          <td>
            <p>
                在一个SplitStream上选择一个或多个流。
                
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">even</span> <span class="k">=</span> <span class="n">split</span> <span class="n">select</span> <span class="s">&quot;even&quot;</span>
<span class="k">val</span> <span class="n">odd</span> <span class="k">=</span> <span class="n">split</span> <span class="n">select</span> <span class="s">&quot;odd&quot;</span>
<span class="k">val</span> <span class="n">all</span> <span class="k">=</span> <span class="n">split</span><span class="o">.</span><span class="n">select</span><span class="o">(</span><span class="s">&quot;even&quot;</span><span class="o">,</span><span class="s">&quot;odd&quot;</span><span class="o">)</span></code></pre></div>

            </p>
          </td>
        </tr>
        <tr>
          <td><strong>Iterate</strong><br />DataStream &rarr; IterativeStream  &rarr; DataStream</td>
          <td>
            <p>
                通过将一个operator的输出重定向到某个先前的operator，在流中创建“反馈”循环。这对于需要不断更新模型的算法特别有用。以下代码以流开始，并持续应用迭代体。大于0的元素将回送到反馈通道，其余元素发往下游。相关完整描述请参阅<a href="#iterations">iterations</a>。
                
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">initialStream</span><span class="o">.</span><span class="na">iterate</span> <span class="o">{</span>
  <span class="n">iteration</span> <span class="o">=&gt;</span> <span class="o">{</span>
    <span class="n">val</span> <span class="n">iterationBody</span> <span class="o">=</span> <span class="n">iteration</span><span class="o">.</span><span class="na">map</span> <span class="o">{</span><span class="cm">/*do something*/</span><span class="o">}</span>
    <span class="o">(</span><span class="n">iterationBody</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">),</span> <span class="n">iterationBody</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">_</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>

            </p>
          </td>
        </tr>
        <tr>
          <td><strong>Extract Timestamps</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>
                从记录中提取时间戳，以便在窗口中使用事件时间语义。请参阅<a href="/1.2.0/apis/streaming/event_time.html">Event Time</a>。
                
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">stream</span><span class="o">.</span><span class="n">assignTimestamps</span> <span class="o">{</span> <span class="n">timestampExtractor</span> <span class="o">}</span></code></pre></div>

            </p>
          </td>
        </tr>
  </tbody>
</table>

    <p>使用如下的匿名模式匹配从元组、case类和集合中抽取信息：</p>

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">data</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="n">data</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">temperature</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// [...]</span>
<span class="o">}</span></code></pre></div>

    <p>未被API原生支持。要使用该特性，请用<a href="scala_api_extensions.html">Scala API extension</a>。</p>

  </div>
</div>

<p>以下transformations可用于元组类型的DataStream：</p>

<div class="codetabs">
  <div data-lang="java">

    <p><br /></p>

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">Transformation</th>
      <th class="text-center">Description</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td><strong>Project</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>从元组中选择一部分字段子集

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">in</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">out</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">project</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span></code></pre></div>

        </p>
      </td>
    </tr>
  </tbody>
</table>

  </div>
</div>

<h3 id="section-1">物理分区</h3>

<p>在一个transformation之后，Flink也提供了底层API以允许用户在必要时精确控制流分区，参见如下的函数。</p>

<div class="codetabs">
  <div data-lang="java">

    <p><br /></p>

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">Transformation</th>
      <th class="text-center">Description</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td><strong>Custom partitioning</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            使用一个用户自定义Partitioner确定每个元素对应的目标task。
            
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">partitionCustom</span><span class="o">(</span><span class="n">partitioner</span><span class="o">,</span> <span class="s">&quot;someKey&quot;</span><span class="o">);</span>
<span class="n">dataStream</span><span class="o">.</span><span class="na">partitionCustom</span><span class="o">(</span><span class="n">partitioner</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span></code></pre></div>

        </p>
      </td>
    </tr>
   <tr>
     <td><strong>Random partitioning</strong><br />DataStream &rarr; DataStream</td>
     <td>
       <p>
            按照均匀分布以随机的方式对元素进行分区。
            
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">shuffle</span><span class="o">();</span></code></pre></div>

       </p>
     </td>
   </tr>
   <tr>
      <td><strong>Rebalancing (Round-robin partitioning)</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            以round-robin方式对元素进行分区，使得每个分区负载均衡。在数据倾斜的情况下进行性能优化有用。
            
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">rebalance</span><span class="o">();</span></code></pre></div>

        </p>
      </td>
    </tr>
    <tr>
      <td><strong>Rescaling</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            以round-robin方式对元素分区到下游operations。如果你想从source的每个并行实例分散到若干个mappers以负载均衡，但是你不期望rebalacne()那样进行全局负载均衡，这将会有用。这将仅需要本地数据传输，而不是通过网络传输数据，具体取决于其他配置值，例如TaskManager的插槽数。
        </p>
        <p>
            上游operation所发送的元素被分区到下游operation的哪些子集，取决于上游和下游操作的并发度。例如，如果上游operation并发度为2，而下游operation并发度为6，则其中1个上游operation会将元素分发到3个下游operation，另1个上游operation会将元素分发到另外3个下游operation。相反地，如果上游operation并发度为6，而下游operation并发度为2，则其中3个上游operation会将元素分发到1个下游operation，另1个上游operation会将元素分发到另外1个下游operation。
        </p>
        <p>
            在上下游operation的并行度不是彼此的倍数的情况下，下游operation对应的上游的operation输入数量不同。
        </p>
        <p>
            下图可视化了上面例子中说明的对应关系：
        </p>

        <div style="text-align: center">
            <img src="/1.2.0/fig/rescale.svg" alt="Checkpoint barriers in data streams" />
            </div>


        <p>
                    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">rescale</span><span class="o">();</span></code></pre></div>


        </p>
      </td>
    </tr>
   <tr>
      <td><strong>Broadcasting</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            广播元素到每个分区。
            
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">broadcast</span><span class="o">();</span></code></pre></div>

        </p>
      </td>
    </tr>
  </tbody>
</table>

  </div>

  <div data-lang="scala">

    <p><br /></p>

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">Transformation</th>
      <th class="text-center">Description</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td><strong>Custom partitioning</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            使用一个用户自定义Partitioner确定每个元素对应的目标task。
            
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">partitionCustom</span><span class="o">(</span><span class="n">partitioner</span><span class="o">,</span> <span class="s">&quot;someKey&quot;</span><span class="o">)</span>
<span class="n">dataStream</span><span class="o">.</span><span class="n">partitionCustom</span><span class="o">(</span><span class="n">partitioner</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span></code></pre></div>

        </p>
      </td>
    </tr>
   <tr>
     <td><strong>Random partitioning</strong><br />DataStream &rarr; DataStream</td>
     <td>
       <p>
            按照均匀分布以随机的方式对元素进行分区。
            
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">shuffle</span><span class="o">()</span></code></pre></div>

       </p>
     </td>
   </tr>
   <tr>
      <td><strong>Rebalancing (Round-robin partitioning)</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            以round-robin方式对元素进行分区，使得每个分区负载均衡。在数据倾斜的情况下进行性能优化有用。
            
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">rebalance</span><span class="o">()</span></code></pre></div>

        </p>
      </td>
    </tr>
    <tr>
      <td><strong>Rescaling</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            以round-robin方式对元素分区到下游operations。如果你想从source的每个并行实例分散到若干个mappers以负载均衡，但是你不期望rebalacne()那样进行全局负载均衡，这将会有用。这将仅需要本地数据传输，而不是通过网络传输数据，具体取决于其他配置值，例如TaskManager的插槽数。
        </p>
        <p>
            上游operation所发送的元素被分区到下游operation的哪些子集，取决于上游和下游操作的并发度。例如，如果上游operation并发度为2，而下游operation并发度为6，则其中1个上游operation会将元素分发到3个下游operation，另1个上游operation会将元素分发到另外3个下游operation。相反地，如果上游operation并发度为6，而下游operation并发度为2，则其中3个上游operation会将元素分发到1个下游operation，另1个上游operation会将元素分发到另外1个下游operation。
        </p>
        <p>
            在上下游operation的并行度不是彼此的倍数的情况下，下游operation对应的上游的operation输入数量不同。

        </p>
        
            下图可视化了上面例子中说明的对应关系：
        

        <div style="text-align: center">
            <img src="/1.2.0/fig/rescale.svg" alt="Checkpoint barriers in data streams" />
            </div>


        <p>
                    
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">rescale</span><span class="o">()</span></code></pre></div>


        </p>
      </td>
    </tr>
   <tr>
      <td><strong>Broadcasting</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            广播元素到每个分区。
            
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">broadcast</span><span class="o">()</span></code></pre></div>

        </p>
      </td>
    </tr>
  </tbody>
</table>

  </div>
</div>

<h3 id="chaining-">任务链接（chaining） 和资源组</h3>

<p>链接（chaining）两个依次的transformations意味着将它们运行在同一个线程中以获得更好的性能。Flink默认情况下尽可能进行该链接操作（比如两个依次的map transformations），同时Flink根据需要提供API对链接进行细粒度控制：</p>

<p>如果不想在整个Job上进行默认的链接优化，可以设置<code>StreamExecutionEnvironment.disableOperatorChaining()</code>。下面的函数可用于更细粒度的控制链接。注意这些函数只能用在一个DataStream transformation之后，因为它们是指向先前的transformation。例如，你可以<code>someStream.map(...).startNewChain()</code>, 但是你不能<code>someStream.startNewChain()</code>.</p>

<p>Flink中的一个资源组是一个slot，详情请参阅<a href="/1.2.0/setup/config.html#configuring-taskmanager-processing-slots">slots</a>. 必要时你可以手动隔离不同slots中的operators。</p>

<div class="codetabs">
  <div data-lang="java">

    <p><br /></p>

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">Transformation</th>
      <th class="text-center">Description</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td>Start new chain</td>
      <td>
        <p>从这个operator开始新建一个新的chain。这两个mappers将被链接起来，而filter不会和第一个mapper链接。

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">someStream</span><span class="o">.</span><span class="na">filter</span><span class="o">(...).</span><span class="na">map</span><span class="o">(...).</span><span class="na">startNewChain</span><span class="o">().</span><span class="na">map</span><span class="o">(...);</span></code></pre></div>

        </p>
      </td>
    </tr>
   <tr>
      <td>Disable chaining</td>
      <td>
        <p>不与这个map operator链接

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">someStream</span><span class="o">.</span><span class="na">map</span><span class="o">(...).</span><span class="na">disableChaining</span><span class="o">();</span></code></pre></div>

        </p>
      </td>
    </tr>
    <tr>
      <td>Set slot sharing group</td>
      <td>
        <p>设置operation的slot共享组。Flink会把相同slot共享组的operation放在同一个slot中，而把没有slot共享组的operation放到其他slot中。这可以用来隔离slot。如果所有输入operation都在相同的slot共享组中，则slot共享组将继承自输入operation。默认slot共享组是“default”，可以通过调用slotSharingGroup（“default”）将operation显式的放入该组。

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">someStream</span><span class="o">.</span><span class="na">filter</span><span class="o">(...).</span><span class="na">slotSharingGroup</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">);</span></code></pre></div>

        </p>
      </td>
    </tr>
  </tbody>
</table>

  </div>

  <div data-lang="scala">

    <p><br /></p>

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">Transformation</th>
      <th class="text-center">Description</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td>Start new chain</td>
      <td>
        <p>从这个operator开始新建一个新的chain。这两个mappers将被链接起来，而filter不会和第一个mapper链接。

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">someStream</span><span class="o">.</span><span class="n">filter</span><span class="o">(...).</span><span class="n">map</span><span class="o">(...).</span><span class="n">startNewChain</span><span class="o">().</span><span class="n">map</span><span class="o">(...)</span></code></pre></div>

        </p>
      </td>
    </tr>
   <tr>
      <td>Disable chaining</td>
      <td>
        <p>不与这个map operator链接

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">someStream</span><span class="o">.</span><span class="n">map</span><span class="o">(...).</span><span class="n">disableChaining</span><span class="o">()</span></code></pre></div>

        </p>
      </td>
    </tr>
  <tr>
      <td>Set slot sharing group</td>
      <td>
        <p>设置operation的slot共享组。Flink会把相同slot共享组的operation放在同一个slot中，而把没有slot共享组的operation放到其他slot中。这可以用来隔离slot。如果所有输入operation都在相同的slot共享组中，则slot共享组将继承自输入operation。默认slot共享组是“default”，可以通过调用slotSharingGroup（“default”）将operation显式的放入该组。

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">someStream</span><span class="o">.</span><span class="na">filter</span><span class="o">(...).</span><span class="na">slotSharingGroup</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">)</span></code></pre></div>

        </p>
      </td>
    </tr>
  </tbody>
</table>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="sources">数据Sources</h2>

<div class="codetabs">
  <div data-lang="java">

    <p><br /></p>

    <p>Sources是你的程序读取输入的地方。你可以通过<code>StreamExecutionEnvironment.addSource(sourceFunction)</code>将Source添加到你的程序中。Flink提供了若干已经实现好了的source functions，当然你也可以通过实现<code>SourceFunction</code>来自定义非并行的source或者实现<code>ParallelSourceFunction</code>接口或者扩展<code>RichParallelSourceFunction</code>来自定义并行的source，</p>

    <p><code>StreamExecutionEnvironment</code>中可以使用以下几个已实现的stream sources：</p>

    <p>基于文件：</p>

    <ul>
      <li>
        <p><code>readTextFile(path)</code> - 读取文本文件，即符合TextInputFormat规范的文件，并将其作为字符串返回。</p>
      </li>
      <li>
        <p><code>readFile(fileInputFormat, path)</code> - 根据指定的文件输入格式读取文件（一次）。</p>
      </li>
      <li>
        <p><code>readFile(fileInputFormat, path, watchType, interval, pathFilter, typeInfo)</code> -  这是上面两个方法内部调用的方法。它根据给定的<code>fileInputFormat</code>和读取路径读取文件。根据提供的<code>watchType</code>，这个source可以定期（每隔<code>interval</code>毫秒）监测给定路径的新数据（<code>FileProcessingMode.PROCESS_CONTINUOUSLY</code>），或者处理一次路径对应文件的数据并退出（<code>FileProcessingMode.PROCESS_ONCE</code>）。你可以通过<code>pathFilter</code>进一步排除掉需要处理的文件。</p>

        <p><em>实现:</em></p>

        <p>在具体实现上，Flink把文件读取过程分为两个子任务，即<em>目录监控</em>和<em>数据读取</em>。每个子任务都由单独的实体实现。目录监控由单个非并行（并行度为1）的任务执行，而数据读取由并行运行的多个任务执行。后者的并行性等于作业的并行性。单个目录监控任务的作用是扫描目录（根据<code>watchType</code>定期扫描或仅扫描一次），查找要处理的文件并把文件分割成<em>切分片（splits）</em>，然后将这些切分片分配给下游reader。reader负责读取数据。每个切分片只能由一个reader读取，但一个reader可以逐个读取多个切分片。</p>

        <p><em>重要注意：</em></p>

        <ol>
          <li>
            <p>如果<code>watchType</code>设置为<code>FileProcessingMode.PROCESS_CONTINUOUSLY</code>，则当文件被修改时，其内容将被重新处理。这会打破“exactly-once”语义，因为在文件末尾附加数据将导致其<strong>所有内容</strong>被重新处理。</p>
          </li>
          <li>
            <p>如果<code>watchType</code>设置为<code>FileProcessingMode.PROCESS_ONCE</code>，则source仅扫描路径一次然后退出，而不等待reader完成文件内容的读取。当然reader会继续阅读，直到读取所有的文件内容。关闭source后就不会再有检查点。这可能导致节点故障后的恢复速度较慢，因为该作业将从最后一个检查点恢复读取。</p>
          </li>
        </ol>
      </li>
    </ul>

    <p>基于 Socket：</p>

    <ul>
      <li><code>socketTextStream</code> - 从socket读取。元素可以用分隔符切分。</li>
    </ul>

    <p>基于集合：</p>

    <ul>
      <li>
        <p><code>fromCollection(Collection)</code> - 从Java的Java.util.Collection创建数据流。集合中的所有元素类型必须相同。</p>
      </li>
      <li>
        <p><code>fromCollection(Iterator, Class)</code> - 从一个迭代器中创建数据流。Class指定了该迭代器返回元素的类型。</p>
      </li>
      <li>
        <p><code>fromElements(T ...)</code> - 从给定的对象序列中创建数据流。所有对象类型必须相同。</p>
      </li>
      <li>
        <p><code>fromParallelCollection(SplittableIterator, Class)</code> - 从一个迭代器中创建并行数据流。Class指定了该迭代器返回元素的类型。</p>
      </li>
      <li>
        <p><code>generateSequence(from, to)</code> - 创建一个生成指定区间范围内的数字序列的并行数据流。</p>
      </li>
    </ul>

    <p>自定义：</p>

    <ul>
      <li><code>addSource</code> - 添加一个新的source function。例如，你可以<code>addSource(new FlinkKafkaConsumer08&lt;&gt;(...))</code>以从Apache Kafka读取数据。详情参阅 <a href="/1.2.0/dev/connectors/index.html">connectors</a>。</li>
    </ul>

  </div>

  <div data-lang="scala">

    <p><br /></p>

    <p>Sources是你的程序读取输入的地方。你可以通过<code>StreamExecutionEnvironment.addSource(sourceFunction)</code>将Source添加到你的程序中。Flink提供了若干已经实现好了的source functions，当然你也可以通过实现<code>SourceFunction</code>来自定义非并行的source或者实现<code>ParallelSourceFunction</code>接口或者扩展<code>RichParallelSourceFunction</code>来自定义并行的source，</p>

    <p><code>StreamExecutionEnvironment</code>中可以使用以下几个已实现的stream sources：</p>

    <p>基于文件：</p>

    <ul>
      <li>
        <p><code>readTextFile(path)</code> - 读取文本文件，即符合TextInputFormat规范的文件，并将其作为字符串返回。</p>
      </li>
      <li>
        <p><code>readFile(fileInputFormat, path)</code> - 根据指定的文件输入格式读取文件（一次）。</p>
      </li>
      <li>
        <p><code>readFile(fileInputFormat, path, watchType, interval, pathFilter)</code> -  这是上面两个方法内部调用的方法。它根据给定的<code>fileInputFormat</code>和读取路径读取文件。根据提供的<code>watchType</code>，这个source可以定期（每隔<code>interval</code>毫秒）监测给定路径的新数据（<code>FileProcessingMode.PROCESS_CONTINUOUSLY</code>），或者处理一次路径对应文件的数据并退出（<code>FileProcessingMode.PROCESS_ONCE</code>）。你可以通过<code>pathFilter</code>进一步排除掉需要处理的文件。</p>

        <p><em>实现:</em></p>

        <p>在具体实现上，Flink把文件读取过程分为两个子任务，即<em>目录监控</em>和<em>数据读取</em>。每个子任务都由单独的实体实现。目录监控由单个非并行（并行度为1）的任务执行，而数据读取由并行运行的多个任务执行。后者的并行性等于作业的并行性。单个目录监控任务的作用是扫描目录（根据<code>watchType</code>定期扫描或仅扫描一次），查找要处理的文件并把文件分割成<em>切分片（splits）</em>，然后将这些切分片分配给下游reader。reader负责读取数据。每个切分片只能由一个reader读取，但一个reader可以逐个读取多个切分片。</p>

        <p><em>重要注意：</em></p>

        <ol>
          <li>
            <p>如果<code>watchType</code>设置为<code>FileProcessingMode.PROCESS_CONTINUOUSLY</code>，则当文件被修改时，其内容将被重新处理。这会打破“exactly-once”语义，因为在文件末尾附加数据将导致其<strong>所有内容</strong>被重新处理。</p>
          </li>
          <li>
            <p>如果<code>watchType</code>设置为<code>FileProcessingMode.PROCESS_ONCE</code>，则source仅扫描路径一次然后退出，而不等待reader完成文件内容的读取。当然reader会继续阅读，直到读取所有的文件内容。关闭source后就不会再有检查点。这可能导致节点故障后的恢复速度较慢，因为该作业将从最后一个检查点恢复读取。</p>
          </li>
        </ol>
      </li>
    </ul>

    <p>基于 Socket：</p>

    <ul>
      <li><code>socketTextStream</code> - 从socket读取。元素可以用分隔符切分。</li>
    </ul>

    <p>Collection-based:</p>

    <ul>
      <li>
        <p><code>fromCollection(Seq)</code> - 从Java的Java.util.Collection创建数据流。集合中的所有元素类型必须相同。</p>
      </li>
      <li>
        <p><code>fromCollection(Iterator)</code> - 从一个迭代器中创建数据流。Class指定了该迭代器返回元素的类型。</p>
      </li>
      <li>
        <p><code>fromElements(elements: _*)</code> - 从给定的对象序列中创建数据流。所有对象类型必须相同。</p>
      </li>
      <li>
        <p><code>fromParallelCollection(SplittableIterator)</code> - 从一个迭代器中创建并行数据流。Class指定了该迭代器返回元素的类型。</p>
      </li>
      <li>
        <p><code>generateSequence(from, to)</code> - 创建一个生成指定区间范围内的数字序列的并行数据流。</p>
      </li>
    </ul>

    <p>自定义：</p>

    <ul>
      <li><code>addSource</code> - 添加一个新的source function。例如，你可以<code>addSource(new FlinkKafkaConsumer08&lt;&gt;(...))</code>以从Apache Kafka读取数据。详情参阅<a href="/1.2.0/dev/connectors/">connectors</a>。</li>
    </ul>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="sinks">数据Sinks</h2>

<div class="codetabs">
  <div data-lang="java">

    <p><br /></p>

    <p>数据sinks消费DataStream并将其发往文件、socket、外部系统或进行打印。Flink自带多种内置的输出格式，这些都被封装在对DataStream的操作背后：</p>

    <ul>
      <li>
        <p><code>writeAsText()</code> / <code>TextOutputFormat</code> - 将元素以字符串形式写入。字符串
   通过调用每个元素的<em>toString()</em>方法获得。</p>
      </li>
      <li>
        <p><code>writeAsCsv(...)</code> / <code>CsvOutputFormat</code> - 将元组写入逗号分隔的csv文件。行和字段
   分隔符均可配置。每个字段的值来自对象的<em>toString()</em>方法。</p>
      </li>
      <li>
        <p><code>print()</code> / <code>printToErr()</code>  - 打印每个元素的<em>toString()</em>值到标准输出/错误输出流。可以配置前缀信息添加到输出，以区分不同<em>print</em>的结果。如果并行度大于1，则task id也会添加到输出前缀上。</p>
      </li>
      <li>
        <p><code>writeUsingOutputFormat()</code> / <code>FileOutputFormat</code> - 自定义文件输出的方法/基类。支持自定义的对象到字节的转换。</p>
      </li>
      <li>
        <p><code>writeToSocket</code> - 根据<code>SerializationSchema</code>把元素写到socket</p>
      </li>
      <li>
        <p><code>addSink</code> - 调用自定义sink function。Flink自带了很多连接其他系统的连接器（connectors）（如
     Apache Kafka），这些连接器都实现了sink function。</p>
      </li>
    </ul>

  </div>
  <div data-lang="scala">

    <p><br /></p>

    <p>Data sinks消费DataStream并将其发往文件、socket、外部系统或进行打印。Flink自带多种内置的输出格式，这些都被封装在对DataStream的操作背后：</p>

    <ul>
      <li>
        <p><code>writeAsText()</code> / <code>TextOutputFormat</code> - 将元素以字符串形式写入。字符串
   通过调用每个元素的<em>toString()</em>方法获得。</p>
      </li>
      <li>
        <p><code>writeAsCsv(...)</code> / <code>CsvOutputFormat</code> - 将元组写入逗号分隔的csv文件。行和字段
   分隔符均可配置。每个字段的值来自对象的<em>toString()</em>方法。</p>
      </li>
      <li>
        <p><code>print()</code> / <code>printToErr()</code>  - 打印每个元素的<em>toString()</em>值到标准输出/错误输出流。可以配置前缀信息添加到输出，以区分不同<em>print</em>的结果。如果并行度大于1，则task id也会添加到输出前缀上。</p>
      </li>
      <li>
        <p><code>writeUsingOutputFormat()</code> / <code>FileOutputFormat</code> - 自定义文件输出的方法/基类。支持自定义的对象到字节的转换。</p>
      </li>
      <li>
        <p><code>writeToSocket</code> - 根据<code>SerializationSchema</code>把元素写到socket</p>
      </li>
      <li>
        <p><code>addSink</code> - 调用自定义sink function。Flink自带了很多连接其他系统的连接器（connectors）（如
     Apache Kafka），这些连接器都实现了sink function。</p>
      </li>
    </ul>

  </div>
</div>

<p>请注意，<code>DataStream</code>上的<code>write*()</code>方法主要用于调试目的。它们没有参与Flink的检查点机制，这意味着这些function通常都有
at-least-once语义。数据刷新到目标系统取决于OutputFormat的实现。这意味着并非所有发送到OutputFormat的元素都会立即在目标系统中可见。此外，在失败的情况下，这些记录可能会丢失。</p>

<p>为了可靠，在把流写到文件系统时，使用<code>flink-connector-filesystem</code>来实现exactly-once。此外，通过<code>.addSink(...)</code>方法自定义的实现可以参与Flink的检查点机制以实现exactly-once语义。</p>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="iterations">迭代（Iterations）</h2>

<div class="codetabs">
  <div data-lang="java">

    <p><br /></p>

    <p>迭代流程序实现一个step function并将其嵌入到<code>IterativeStream</code>中。由于这样的DataStream程序可能永远不会结束，所以没有最大迭代次数。事实上你需要指定哪一部分的流被反馈到迭代过程，哪个部分通过<code>split</code> 或<code>filter</code> transformation向下游转发。在这里，我们展示一个使用过滤器的例子。首先，我们定义一个<code>IterativeStream</code></p>

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">IterativeStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">iteration</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">iterate</span><span class="o">();</span></code></pre></div>

    <p>然后，我们使用一系列transformations来指定在循环内执行的逻辑（这里示意一个简单的<code>map</code> transformation）</p>

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">iterationBody</span> <span class="o">=</span> <span class="n">iteration</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="cm">/* this is executed many times */</span><span class="o">);</span></code></pre></div>

    <p>要关闭迭代并定义迭代尾部，需要调用<code>IterativeStream</code>的<code>closeWith(feedbackStream)</code>方法。传给<code>closeWith</code> function的DataStream将被反馈给迭代的头部。一种常见的模式是使用filter来分离流中需要反馈的部分和需要继续发往下游的部分。这些filter可以定义“终止”逻辑，以控制元素是流向下游而不是反馈迭代。</p>

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">iteration</span><span class="o">.</span><span class="na">closeWith</span><span class="o">(</span><span class="n">iterationBody</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="cm">/* one part of the stream */</span><span class="o">));</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">iterationBody</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="cm">/* some other part of the stream */</span><span class="o">);</span></code></pre></div>

    <p>默认情况下，反馈流的分区将自动设置为与迭代的头部的输入分区相同。用户可以在<code>closeWith</code>方法中设置一个可选的boolean标志来覆盖默认行为。</p>

    <p>例如，如下程序从一系列整数连续减1，直到它们达到零：</p>

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">someIntegers</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">generateSequence</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">);</span>

<span class="n">IterativeStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">iteration</span> <span class="o">=</span> <span class="n">someIntegers</span><span class="o">.</span><span class="na">iterate</span><span class="o">();</span>

<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">minusOne</span> <span class="o">=</span> <span class="n">iteration</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Long</span> <span class="nf">map</span><span class="o">(</span><span class="n">Long</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">value</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">;</span>
  <span class="o">}</span>
<span class="o">});</span>

<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">stillGreaterThanZero</span> <span class="o">=</span> <span class="n">minusOne</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Long</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">});</span>

<span class="n">iteration</span><span class="o">.</span><span class="na">closeWith</span><span class="o">(</span><span class="n">stillGreaterThanZero</span><span class="o">);</span>

<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">lessThanZero</span> <span class="o">=</span> <span class="n">minusOne</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Long</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">});</span></code></pre></div>

  </div>
  <div data-lang="scala">

    <p><br /></p>

    <p>迭代streaming程序实现一个step function并将其嵌入到<code>IterativeStream</code>中。由于这样的DataStream程序可能永远不会结束，所以没有最大迭代次数。事实上你需要指定哪一部分的流被反馈到迭代过程，哪个部分通过<code>split</code> 或<code>filter</code> transformation向下游转发。在这里，我们展示一个迭代的例子，其中主体（计算部分被反复执行）是简单的map transformation，迭代反馈的元素和继续发往下游的元素通过filters进行区分。</p>

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">iteratedStream</span> <span class="k">=</span> <span class="n">someDataStream</span><span class="o">.</span><span class="n">iterate</span><span class="o">(</span>
  <span class="n">iteration</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">iterationBody</span> <span class="k">=</span> <span class="n">iteration</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="cm">/* this is executed many times */</span><span class="o">)</span>
    <span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="cm">/* one part of the stream */</span><span class="o">),</span> <span class="n">tail</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="cm">/* some other part of the stream */</span><span class="o">))</span>
<span class="o">})</span></code></pre></div>

    <p>默认情况下，反馈流的分区将自动设置为与迭代的头部的输入分区相同。用户可以在<code>closeWith</code>方法中设置一个可选的boolean标志来覆盖默认行为。</p>

    <p>例如，如下程序从一系列整数连续减1，直到它们达到零：</p>

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">someIntegers</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">generateSequence</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">)</span>

<span class="k">val</span> <span class="n">iteratedStream</span> <span class="k">=</span> <span class="n">someIntegers</span><span class="o">.</span><span class="n">iterate</span><span class="o">(</span>
  <span class="n">iteration</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">minusOne</span> <span class="k">=</span> <span class="n">iteration</span><span class="o">.</span><span class="n">map</span><span class="o">(</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">stillGreaterThanZero</span> <span class="k">=</span> <span class="n">minusOne</span><span class="o">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">lessThanZero</span> <span class="k">=</span> <span class="n">minusOne</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
    <span class="o">(</span><span class="n">stillGreaterThanZero</span><span class="o">,</span> <span class="n">lessThanZero</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">)</span></code></pre></div>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="section-2">执行参数</h2>

<p><code>StreamExecutionEnvironment</code>包含<code>ExecutionConfig</code>，它允许为作业运行时进行配置。</p>

<p>更多配置参数请参阅<a href="/1.2.0/dev/execution_configuration.html">execution configuration</a>。下面的参数是DataStream API特有的：</p>

<ul>
  <li>
    <p><code>enableTimestamps()</code> / <strong><code>disableTimestamps()</code></strong>: 如果启用，则从source发出的每一条记录都会附加一个时间戳。
  <code>areTimestampsEnabled()</code> 返回当前是否启用该值。</p>
  </li>
  <li>
    <p><code>setAutoWatermarkInterval(long milliseconds)</code>: 设置自动发射watermark的间隔。你可以通过<code>long getAutoWatermarkInterval()</code>获取当前的发射间隔。</p>
  </li>
</ul>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h3 id="section-3">容错</h3>

<p><a href="/1.2.0/dev/stream/checkpointing.html">State &amp; Checkpointing</a> 描述了如何开启和配置Flink的checkpointing机制。</p>

<h3 id="section-4">延迟控制</h3>

<p>默认情况下，元素不会逐个传输（这将导致不必要的网络流量），而是被缓冲的。缓冲（实际是在机器之间传输）的大小可以在Flink配置文件中设置。虽然这种方法对于优化吞吐量有好处，但是当输入流不够快时，它可能会导致延迟问题。要控制吞吐量和延迟，你可以在execution environment（或单个operator）上使用<code>env.setBufferTimeout(timeoutMillis)</code>来设置缓冲区填满的最大等待时间。如果超过该最大等待时间，即使缓冲区未满，也会被自动发送出去。该最大等待时间默认值为100 ms。</p>

<p>Usage:</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">LocalStreamEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">createLocalEnvironment</span><span class="o">();</span>
<span class="n">env</span><span class="o">.</span><span class="na">setBufferTimeout</span><span class="o">(</span><span class="n">timeoutMillis</span><span class="o">);</span>

<span class="n">env</span><span class="o">.</span><span class="na">generateSequence</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="nf">MyMapper</span><span class="o">()).</span><span class="na">setBufferTimeout</span><span class="o">(</span><span class="n">timeoutMillis</span><span class="o">);</span></code></pre></div>

  </div>
  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="nc">LocalStreamEnvironment</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">createLocalEnvironment</span>
<span class="n">env</span><span class="o">.</span><span class="n">setBufferTimeout</span><span class="o">(</span><span class="n">timeoutMillis</span><span class="o">)</span>

<span class="n">env</span><span class="o">.</span><span class="n">genereateSequence</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">myMap</span><span class="o">).</span><span class="n">setBufferTimeout</span><span class="o">(</span><span class="n">timeoutMillis</span><span class="o">)</span></code></pre></div>

  </div>
</div>

<p>为了最大化吞吐量，可以设置<code>setBufferTimeout(-1)</code>，这样就没有了超时机制，缓冲区只有在满时才会发送出去。为了最小化延迟，可以把超时设置为接近0的值（例如5或10 ms）。应避免将该超时设置为0，因为这样可能导致性能严重下降。</p>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="section-5">调试</h2>

<p>在分布式集群中运行Streaming程序之前，最好确保实现的算法可以正常工作。因此，实施数据分析程序通常是一个渐进的过程：检查结果，调试和改进。</p>

<p>Flink提供了诸多特性来大幅简化数据分析程序的开发：你可以在IDE中进行本地调试，注入测试数据，收集结果数据。本节给出一些如何简化Flink程序开发的指导。</p>

<h3 id="section-6">本地执行环境</h3>

<p><code>LocalStreamEnvironment</code>会在其所在的进程中启动一个Flink引擎. 如果你在IDE中启动LocalEnvironment，你可以在你的代码中设置断点，轻松调试你的程序。</p>

<p>一个LocalEnvironment的创建和使用示例如下：</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">createLocalEnvironment</span><span class="o">();</span>

<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">addSource</span><span class="o">(</span><span class="cm">/* some source */</span><span class="o">);</span>
<span class="c1">// build your program</span>

<span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span></code></pre></div>

  </div>
  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">createLocalEnvironment</span><span class="o">()</span>

<span class="k">val</span> <span class="n">lines</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">addSource</span><span class="o">(</span><span class="cm">/* some source */</span><span class="o">)</span>
<span class="c1">// build your program</span>

<span class="n">env</span><span class="o">.</span><span class="n">execute</span><span class="o">()</span></code></pre></div>

  </div>
</div>

<h3 id="sources-1">基于集合的数据Sources</h3>

<p>Flink提供了基于Java集合实现的特殊数据sources用于测试。一旦程序通过测试，它的sources和sinks可以方便的替换为从外部系统读写的sources和sinks。</p>

<p>基于集合的数据Sources可以像这样使用：</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">createLocalEnvironment</span><span class="o">();</span>

<span class="c1">// Create a DataStream from a list of elements</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">myInts</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>

<span class="c1">// Create a DataStream from any Java collection</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">myTuples</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromCollection</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>

<span class="c1">// Create a DataStream from an Iterator</span>
<span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">longIt</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">myLongs</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromCollection</span><span class="o">(</span><span class="n">longIt</span><span class="o">,</span> <span class="n">Long</span><span class="o">.</span><span class="na">class</span><span class="o">);</span></code></pre></div>

  </div>
  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">createLocalEnvironment</span><span class="o">()</span>

<span class="c1">// Create a DataStream from a list of elements</span>
<span class="k">val</span> <span class="n">myInts</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="c1">// Create a DataStream from any Collection</span>
<span class="k">val</span> <span class="n">data</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="n">myTuples</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>

<span class="c1">// Create a DataStream from an Iterator</span>
<span class="k">val</span> <span class="n">longIt</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="n">myLongs</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">longIt</span><span class="o">)</span></code></pre></div>

  </div>
</div>

<p><strong>注意：</strong>目前，集合数据source要求数据类型和迭代器实现<code>Serializable</code>。并行度 = 1）。</p>

<h3 id="sink">迭代的数据Sink</h3>

<p>Flink还提供了一个sink来收集DataStream的测试和调试结果。它可以这样使用：</p>

<div class="codetabs">
  <div data-lang="java">

    <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">org.apache.flink.contrib.streaming.DataStreamUtils</span>

<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">myResult</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">myOutput</span> <span class="o">=</span> <span class="n">DataStreamUtils</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">myResult</span><span class="o">)</span></code></pre></div>

  </div>
  <div data-lang="scala">

    <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.contrib.streaming.DataStreamUtils</span>
<span class="k">import</span> <span class="nn">scala.collection.JavaConverters.asScalaIteratorConverter</span>

<span class="k">val</span> <span class="n">myResult</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="n">myOutput</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">DataStreamUtils</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="n">myResult</span><span class="o">.</span><span class="n">getJavaStream</span><span class="o">).</span><span class="n">asScala</span></code></pre></div>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>


 <div class="footer">
  发现错误？想参与编辑？
  <a href="https://github.com/flink-china/flink-china-doc/edit/1.2.0/dev/datastream_api.md" target="_blank">
    在 Github 上编辑此页！
  </a>
</div>

        </div>
      </div>
    </div><!-- /.container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.1.0/anchor.min.js"></script>
    <script src="/1.2.0/page/js/flink.js"></script>

   <!-- Baidu Analytics -->
    <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?835985ad7943d8c24bc3c1f155b7d4a2";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    </script>

    <!-- Disqus -->
    
  </body>
</html>
